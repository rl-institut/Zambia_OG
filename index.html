<!Doctype html>
<html>
    <head>
        <meta charset=utf-8 />
        <title>Zambia Map</title>

        <!-- font awesome offers symbols/icons. used e.g. as symbols for the tabs on the sidebar -->
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
        <!-- Stylesheet for Leaflet icons, fonts etc -->
        <link rel="stylesheet" href="css/leaflet.css"/>
        <link rel="stylesheet" href="css/leaflet.measure.css" />
        <link rel="stylesheet" href="css/leaflet-sidebar.min.css" />
        <link rel="stylesheet" href="css/will-change-memory.css">

        <!-- Stylesheet for nouislider -->
        <link rel="stylesheet" href="css/nouislider.min.css" />

        <link rel="stylesheet" href="css/MarkerCluster.css"/>
        <link rel="stylesheet" href="css/MarkerCluster.Default.css"/>

        <!-- Stylesheet defines map extent -->
        <link rel="stylesheet" href="css/styles.css"/>

    </head>

    <body>

        <!--Leaflet - JS-library for slippy maps -->
        <script src="javascript/leaflet.js"></script>
        <!--jquery - enables loading a GeoJson from a file directly into Leaflet -->
        <script src="javascript/jquery.min.js"></script>
        <!--enables loading vectortiles -->
        <script src="javascript/Leaflet.VectorGrid.bundled.js"></script>
        <!--enables pretty checkboxes and advanced slider functions -->
        <script src="javascript/nouislider.min.js"></script>
        <!--enables the leaflet-sidebar -->
        <script src="javascript/leaflet-sidebar.min.js"></script>
        <!--enables the measure tool -->
        <script src="javascript/leaflet.measure.js""></script>



        <!--clusters -->
        <script src="javascript/leaflet.markercluster-src.js"></script>
        <!--Points for clustering purposes -->
        <script src="data/points.js"></script>

        <!--importing js-files with geojson inside. this approach is chosen, since loading geojson-files directly into a variable can be problematic  -->
        <!--variable centroids with points for all clusters -->
        <script src="data/centroids.js" type="text/javascript"></script>
        <!--provinces.js contains a javascript variable named "provinces" with all geojson objects inside -->
        <script src="data/sampledata_provinces.js" type="text/javascript"></script>
        <!--nouislider enables better looking checkboxes and more functional sliders -->


    <div id="map"></div>

    <div id="sidebar" class="leaflet-sidebar">
        <div class="leaflet-sidebar-tabs">
            <ul role="tablist">
                <li><a href="#home" role="tab"><i class="fa fa-bars"></i></a></li>
                <li><a href="#key" role="tab"><i class="fa fa-key"></i></a></li>
                <li><a href="#layers" role="tab"><i class="fa fa-layer-group"></i></a></li>
                <li><a href="#settings" role="tab"><i class="fa fa-filter"></i></a></li>
                <li><a href="#download" role="tab"><i class="fa fa-arrow-circle-down"></i></a></li>
                <li><a href="#about" role="tab"><i class="fa fa-question-circle"></i></a></li>
            </ul>
        </div>
    <div class="leaflet-sidebar-content">
        <div class="leaflet-sidebar-pane active" id="home">
            <h1 class="leaflet-sidebar-header">
                 Title next to Sidebar Icon
                <div class="leaflet-sidebar-close"><i class="fa fa-times"></i></div>
            </h1>
            <p> html content in paragraph. You may include an image as well:</p>

            <p class="license"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
            </a><br />The image links to the CC-website. Here is the same link again: <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a>.</p>
        </div>

        <div class="leaflet-sidebar-pane" id="layers">
            <h1 class="leaflet-sidebar-header">Layers<span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
            <h3>Select Basemap Layer </h3>
            <img class="basemap_preview" id="aerial_preview" src="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/6/34/36.png" onclick="SelectBasemap('Esri Aerial')" />
            Aerial Images (Esri) <br>
            <img class="basemap_preview" id="osm_preview" src="https://a.tile.openstreetmap.de/tiles/osmde/6/36/34.png" onclick="SelectBasemap('OpenStreetMap')"/>
            OpenStreetMap <br>
            <img class="basemap_preview" id="topo_preview" src="https://a.tile.opentopomap.org/6/36/34.png" onclick="SelectBasemap('OpenTopoMap')"/>
            OpenTopoMap <br>
            </p>


            <script>
            function url_from_coords(zoom, coords) {
               xtile = long2tile(coords.lng,zoom);
               ytile = long2tile(coords.lat * -1,zoom);
               return zoom + "/" + xtile + "/" + ytile;
            }
            function url_from_coords_yx(zoom, coords) {
               xtile = long2tile(coords.lng,zoom);
               ytile = long2tile(coords.lat * -1,zoom);
               return zoom + "/" + ytile + "/" + xtile;
            }

            function long2tile(lon,zoom) { return (Math.floor((lon+180)/360*Math.pow(2,zoom))); }
            function lat2tile(lat,zoom)  { return (Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom))); }

            function RefreshPreview(){
                document.getElementById("topo_preview").src="https://a.tile.opentopomap.org/" + url_from_coords(map.getZoom(), map.getCenter()) + ".png"
                document.getElementById("osm_preview").src="https://a.tile.openstreetmap.de/tiles/osmde/" + url_from_coords(map.getZoom(), map.getCenter()) + ".png"
                document.getElementById("aerial_preview").src="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/" + url_from_coords_yx(map.getZoom(), map.getCenter()) + ".png"
                }

            function SelectBasemap(input){
                var i;
                var maps = ["Esri Aerial", "OpenStreetMap", "OpenTopoMap", "Solar Irradiation"];
                for (i = 0; i < maps.length; i++){
                    if (map.hasLayer(baseMaps[maps[i]]) && maps[i] != input)
                        {
                        map.removeLayer(baseMaps[maps[i]]);
                        //alert(maps[i]);
                        }
                    }
                map.addLayer(baseMaps[input]);
                baseMaps[input].bringToBack();
            }

                </script>

<!--
                basemap layer seletor with radio buttons
                <form action="">
                  <input type="radio" name="basemap" id="Esri Aerial" onclick="BaseMapSwitch()" checked> Aerial Images (Esri)<br>
                  <input type="radio" name="basemap" id="OpenStreetMap" onclick="BaseMapSwitch()" > OpenStreetMap<br>
                  <input type="radio" name="basemap" id="Grayscale" onclick="BaseMapSwitch()" > OpenStreetMap-Gray<br>
                  <input type="radio" name="basemap" id="OpenTopoMap" onclick="BaseMapSwitch()" > OpenTopoMap<br>
                </form>

                <script>
                function BaseMapSwitch() {
                    var x = document.getElementsByName("basemap");
                    var i;
                    for (i = 0; i < x.length; i++) {
                        if (x[i].checked){
                            map.addLayer(baseMaps[x[i].id]);
                        }
                        else {
                            map.removeLayer(baseMaps[x[i].id]);
                        }

                    }
                }


                </script>
-->
            <h3>Select Overlay Information </h3>
            <br>
            <label class="switch">
                <input checked type="checkbox" onclick="toggleVecTileLayer()" id="toggle_vl"/>
                <span class="slider"></span>
            </label> Show Clusters

            <script>

            function toggleVecTileLayer()
            {
                var checkbox = document.getElementById('toggle_vl');
                if (checkbox.checked == false)
                    {
                      if (map.hasLayer(vecTileLayer))
                          {
                          map.removeLayer(vecTileLayer);
                          }
                    }
              else
                    {
                      map.addLayer(vecTileLayer);
                    }
            }
            </script>

                <br><br>
                <label class="switch">
                    <input type="checkbox" name="togglebutton" onclick="toggleBorders()" id="Borders"/>
                    <span class="slider"></span>
                </label> Show Borders

                <br><br>
                <label class="switch">
                    <input checked type="checkbox" name="togglebutton" onclick="toggleBorders()" id="Cluster Accumulations"/>
                    <span class="slider"></span>
                </label> Show Cluster Accumulations


                <script>
                function toggleBorders(){
                    var checkboxes = document.getElementsByName('togglebutton');
                    var j;
                    for (j = 0; j < checkboxes.length; j++) {
                        //alert(typeof(checkboxes[j].id));
                        if (checkboxes[j].checked == false)
                        {
                            //alert(typeof(gray));
                            map.removeLayer(overlaymaps[checkboxes[j].id]);
                        }
                        else {
                            map.addLayer(overlaymaps[checkboxes[j].id]);
                        }   
                    }
                }


                </script>


               <h3>Buildings</h3> 
                <div id="sliderbuild"></div> <br>
                    <div>
                        <input type="number" id="input-with-keypress-0" name="range" />
                        <input type="number" id="input-with-keypress-1" name="range" />
                    </div>

               <h3>Building Density</h3> 
                <div id="sliderbdens"></div> <br>
                    <div>
                        <input type="number" id="input-with-keypress-2" name="range" />
                        <input type="number" id="input-with-keypress-3" name="range" />
                    </div>

               <h3>Distance to Grid (m)</h3> 
                <div id="sliderdist"></div> <br>
                    <div>
                        <input type="number" id="input-with-keypress-4" name="range" />
                        <input type="number" id="input-with-keypress-5" name="range" />
                    </div>

               <h3>Area (km²)</h3> 
                <div id="sliderarea"></div> <br>
                    <div>
                        <input type="number" id="input-with-keypress-6" name="range" step="0.02"/>
                        <input type="number" id="input-with-keypress-7" name="range" step="0.02"/>
                    </div>

                <h3>Select Raster Overlays</h3>
                <br>
                 <label class="switch"> 
                    <input name="" type="checkbox" onclick="toggleGHI()" id="toggle_ghi"/>
                    <span class="slider"></span>
                </label> Show Solar Irradiation
        </div>

                <script>
                function toggleGHI()
                {
                  var checkbox = document.getElementById('toggle_ghi');
                  if (checkbox.checked == false)
                      {
                        if (map.hasLayer(ghi))
                            {
                            map.removeLayer(ghi);
                            }
                      }
                  else
                      {
                        map.addLayer(ghi);
                      }
                }
        </script>
        
            <div class="leaflet-sidebar-pane" id="settings">
                <h1 class="leaflet-sidebar-header">Filter<span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
                <h3>Headline</h3> Paragraph<br> create filters for data below 
             </div>

            <script>
            var currentfilter = {
                minbuild: 0,
                maxbuild: 6000,
                minarea: 0.0,
                maxarea: 10.0,
                minbdens: 0,
                maxbdens: 3000,
                mindist: 0,
                maxdist: 241000,
                mobile: 1
            };

            var currentSelection = null;
            
            // measuring is used in leaflet.measure.js
            var measuring = false; // ! check dependencies before deleting this variable

            var buildingSlider = document.getElementById('sliderbuild');
            var bdensitySlider = document.getElementById('sliderbdens');
            var distanceSlider = document.getElementById('sliderdist');
            var areaSlider = document.getElementById('sliderarea');

            var input0 = document.getElementById('input-with-keypress-0');
            var input1 = document.getElementById('input-with-keypress-1');
            var input2 = document.getElementById('input-with-keypress-2');
            var input3 = document.getElementById('input-with-keypress-3');
            var input4 = document.getElementById('input-with-keypress-4');
            var input5 = document.getElementById('input-with-keypress-5');
            var input6 = document.getElementById('input-with-keypress-6');
            var input7 = document.getElementById('input-with-keypress-7');

            var inputs_build = [input0, input1];
            var inputs_bdens = [input2, input3];
            var inputs_dist = [input4, input5];
            var inputs_area = [input6, input7];

            // create sliders and connect to input fields and functions
            //buildings
            noUiSlider.create(buildingSlider, {
                start: [currentfilter.minbuild, currentfilter.maxbuild],
                connect: true,
                range: {
                    'min': [0, 1],
                    'max': currentfilter.maxbuild
                }
            });
            buildingSlider.noUiSlider.on('update', function( values, handle ) {
                inputs_build[handle].value = values[handle];
            });
            buildingSlider.noUiSlider.on('change', function( values, handle ) {
                currentfilter.minbuild = values[0];
                currentfilter.maxbuild = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            buildingSlider.noUiSlider.on('set', function( values, handle ) {
                currentfilter.minbuild = values[0];
                currentfilter.maxbuild = values[1];
                map.fireEvent("filterchange", currentfilter);
            });

            function setBuildingsHandle(i, value) {
                var r = [null,null];
                r[i] = value;
                buildingSlider.noUiSlider.set(r);
            }

            //building-density
            noUiSlider.create(bdensitySlider, {
                start: [currentfilter.minbdens, currentfilter.maxbdens],
                connect: true,
                range: {
                    'min': [0, 1],
                    'max': currentfilter.maxbdens
                }
            });
            bdensitySlider.noUiSlider.on('update', function( values, handle ) {
                inputs_bdens[handle].value = values[handle];
            });
            bdensitySlider.noUiSlider.on('change', function( values, handle ) {
                currentfilter.minbdens = values[0];
                currentfilter.maxbdens = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            bdensitySlider.noUiSlider.on('set', function( values, handle ) {
                currentfilter.minbdens = values[0];
                currentfilter.maxbdens = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            function setBDensHandle(i, value) {
                var r = [null,null];
                r[i] = value;
                bdensitySlider.noUiSlider.set(r);
            }


            //grid distance
            noUiSlider.create(distanceSlider, {
                start: [currentfilter.mindist, currentfilter.maxdist],
                connect: true,
                range: {
                    'min': [0, 1],
                    'max': currentfilter.maxdist
                }
            });
            distanceSlider.noUiSlider.on('update', function( values, handle ) {
                inputs_dist[handle].value = values[handle];
            });
            distanceSlider.noUiSlider.on('change', function( values, handle ) {
                currentfilter.mindist = values[0];
                currentfilter.maxdist = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            distanceSlider.noUiSlider.on('set', function( values, handle ) {
                currentfilter.mindist = values[0];
                currentfilter.maxdist = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            function setDistHandle(i, value) {
                var r = [null,null];
                r[i] = value;
                distanceSlider.noUiSlider.set(r);
            }


            //grid area
            noUiSlider.create(areaSlider, {
                start: [currentfilter.minarea, currentfilter.maxarea],
                connect: true,
                range: {
                    'min': [0, 0.02],
                    'max': currentfilter.maxarea
                }
            });
            areaSlider.noUiSlider.on('update', function( values, handle ) {
                inputs_area[handle].value = values[handle];
            });
            areaSlider.noUiSlider.on('change', function( values, handle ) {
                currentfilter.minarea = values[0];
                currentfilter.maxarea = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            areaSlider.noUiSlider.on('set', function( values, handle ) {
                currentfilter.minarea = values[0];
                currentfilter.maxarea = values[1];
                map.fireEvent("filterchange", currentfilter);
            });
            function setAreaHandle(i, value) {
                var r = [null,null];
                r[i] = value;
                areaSlider.noUiSlider.set(r);
            }

            // Listen to keydown events on the input field.
            inputs_build.forEach(function(input, handle) {
                input.addEventListener('change', function(){
                    setBuildingsHandle(handle, this.value);
                });
                input.addEventListener('keydown', function( e ) {
                    var values = buildingSlider.noUiSlider.get();
                    var value = Number(values[handle]);
                    // [[handle0_down, handle0_up], [handle1_down, handle1_up]]
                    var steps = buildingSlider.noUiSlider.steps();
                    // [down, up]
                    var step = steps[handle];
                    var position;
                    // 13 is enter,
                    // 38 is key up,
                    // 40 is key down.
                    switch ( e.which ) {
                        case 13:
                            setBuildingsHandle(handle, this.value);
                            break;
                        case 38:
                            // Get step to go increase slider value (up)
                            position = step[1];
                            // false = no step is set
                            if ( position === false ) {
                                position = 1;
                            }
                            // null = edge of slider
                            if ( position !== null ) {
                                setBuildingsHandle(handle, value + position);
                            }

                            break;
                        case 40:
                            position = step[0];
                            if ( position === false ) {
                                position = 1;
                            }
                            if ( position !== null ) {
                                setBuildingsHandle(handle, value - position);
                            }
                            break;
                    }
                });
            });

            // Listen to keydown events on the input field.
            inputs_bdens.forEach(function(input, handle) {
                input.addEventListener('change', function(){
                    setBDensHandle(handle, this.value);
                });
                input.addEventListener('keydown', function( e ) {
                    var values = bdensitySlider.noUiSlider.get();
                    var value = Number(values[handle]);
                    // [[handle0_down, handle0_up], [handle1_down, handle1_up]]
                    var steps = bdensitySlider.noUiSlider.steps();
                    // [down, up]
                    var step = steps[handle];
                    var position;
                    // 13 is enter,
                    // 38 is key up,
                    // 40 is key down.
                    switch ( e.which ) {
                        case 13:
                            setBDensHandle(handle, this.value);
                            break;
                        case 38:
                            // Get step to go increase slider value (up)
                            position = step[1];
                            // false = no step is set
                            if ( position === false ) {
                                position = 1;
                            }
                            // null = edge of slider
                            if ( position !== null ) {
                                setBDensHandle(handle, value + position);
                            }

                            break;
                        case 40:
                            position = step[0];
                            if ( position === false ) {
                                position = 1;
                            }
                            if ( position !== null ) {
                                setBDensHandle(handle, value - position);
                            }
                            break;
                    }
                });
            });


            // Listen to keydown events on the input field.
            inputs_dist.forEach(function(input, handle) {
                input.addEventListener('change', function(){
                    setDistHandle(handle, this.value);
                });
                input.addEventListener('keydown', function( e ) {
                    var values = distanceSlider.noUiSlider.get();
                    var value = Number(values[handle]);
                    // [[handle0_down, handle0_up], [handle1_down, handle1_up]]
                    var steps = distanceSlider.noUiSlider.steps();
                    // [down, up]
                    var step = steps[handle];
                    var position;
                    // 13 is enter,
                    // 38 is key up,
                    // 40 is key down.
                    switch ( e.which ) {
                        case 13:
                            setDistHandle(handle, this.value);
                            break;
                        case 38:
                            // Get step to go increase slider value (up)
                            position = step[1];
                            // false = no step is set
                            if ( position === false ) {
                                position = 1;
                            }
                            // null = edge of slider
                            if ( position !== null ) {
                                setDistHandle(handle, value + position);
                            }

                            break;
                        case 40:
                            position = step[0];
                            if ( position === false ) {
                                position = 1;
                            }
                            if ( position !== null ) {
                                setDistHandle(handle, value - position);
                            }
                            break;
                    }
                });
            });

            // Listen to keydown events on the input field.
            inputs_area.forEach(function(input, handle) {
                input.addEventListener('change', function(){
                    setAreaHandle(handle, this.value);
                });
                input.addEventListener('keydown', function( e ) {
                    var values = areaSlider.noUiSlider.get();
                    var value = Number(values[handle]);
                    var steps = areaSlider.noUiSlider.steps();
                    var step = steps[handle];
                    var position;
                    switch ( e.which ) {
                        case 13:
                            setAreaHandle(handle, this.value);
                            break;
                        case 38:
                            position = step[1];
                            if ( position === false ) {
                                position = 1;
                            }
                            if ( position !== null ) {
                                setAreaHandle(handle, value + position);
                            }
                            break;
                        case 40:
                            position = step[0];
                            if ( position === false ) {
                                position = 1;
                            }
                            if ( position !== null ) {
                                setAreaHandle(handle, value - position);
                            }
                            break;
                    }
                });
            });

            </script>


            <div class="leaflet-sidebar-pane" id="about">
                <h1 class="leaflet-sidebar-header">
                     About the map
                    <div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div>
                </h1>
               <p>Source code for the webmap can be found <a href="https://github.com/rl-institut/Zambia_OG" target="_blank">here</a>.</p>
                <p class="license"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
            </div>


            <div class="leaflet-sidebar-pane" id="download">
                <h1 class="leaflet-sidebar-header">
                        Download
                        <div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div>
                    </h1>
                <p>Lorem ipsum dolores paragraphum</p>
            </div>


            <div class="leaflet-sidebar-pane" id="key">
                <h1 class="leaflet-sidebar-header">
                        Key
                        <div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div>
                    </h1>
                <p>Every Map needs a key.</p>
            </div>


        </div>
    </div>



        <script>
            let options = {
                center: [-13.22, 27.85],
                zoom: 6,
                //center: [-16.2951, 26.6655],
                //zoom: 12,
                minZoom: 6,
                maxZoom: 16,
                zoomControl: false,
                //maxBounds: [[-24, 7],[-2, 48]]
            }

            //
            // Create empty leaflet-map (named "map") on canvas with parameters defined in options
            //

            let map = L.map("map", options);

            //
            // Definition of Basemap-Tile Sources to add map 
            // find more basemaps here (please inspect licenses): https://mc.bbbike.org/mc/?num=2&mt0=mapnik&mt1=mapnik-bw
            //


            let osm = L.tileLayer("https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.de/index.html">OpenStreetMap (de)</a>'
            });

            let topo = L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: '&copy; <a href="https://opentopomap.org">OpenTopoMap</a>'
            });

            let aerial = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
                maxZoom: 19,
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }).addTo(map);    

            let ghi = L.tileLayer("https://wam.rl-institut.de:84/data/ghi/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: '&copy; <a href="www.http://globalsolaratlas.info/">Global Solar Atlas</a>'
            });   // .addTo(map) loads this as the initial basemap    ;


            // define Popups for all features in map 

            
            function onEachFeature(feature, layer) {
                let popupContent = "<b> Sweet Popup Title</b><br>"; //define popuptitle here, if needed. fails to load if it references missing key in one of the elements

            // iterate through all properties of all features and display them in popup
                Object.keys(feature.properties).forEach(function(key,index) {
                    popupContent = popupContent + "<b>" + key + ":</b> " + feature.properties[key] + "<br>";
                });

                if (feature.properties && feature.properties.popupContent) {
                    popupContent += feature.properties.popupContent;
                        }

                        layer.bindPopup(popupContent);
                    }

            //select datasources and apply style
            let circles = L.geoJSON([centroids], {
                style: function (feature) {
                    return feature.properties && feature.properties.style;
                },
                // uncomment below to allow popups for this layer
                 onEachFeature: onEachFeature,

                    pointToLayer: function (feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: 8,
                            fillColor: "#ff7800",
                            color: "#000",
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8,
                        });
                    }
            });






            //select datasources and apply style
            let borders = L.geoJSON([provinces], {
                style: function (feature) {
                    return {
                        weight: 2,
                        opacity: 0.9,
                        color: '#ffffff',
                        //dashArray: '2',
                        fillOpacity: 0.1,
                        fillColor: 'ffffff'
                    };
                },

            });

            // zooms to extent of clicked region
            // assumes that borders are a path or polygon, not a point
            borders.on("click", function (event) {
                map.fitBounds(event.layer.getBounds());
                            //map.removeLayer(borders);
                //document.getElementById('Borders').checked = false; 
            });


        var info = L.control({position: 'bottomright'});

        var highlightStyle = {
            fillColor: "#0044ff",
            fillOpacity: 0.5,
            stroke: true,
            fill: true,
            color: "#0044ff",
            opacity: 0.5,
            weight: 2
        };

        var normalStyle = {
            fillOpacity: 0.5,
            weight: 1,
            stroke: true,
            fill: true,
            fillOpacity: 0.5,
            color: "#111111",
            fillColor: "red",
            
        };

        var magicStyle = {
            fillColor: "#00ffff",
            fillOpacity: 0.5,
            stroke: true,
            fill: true,
            color: "#ff44ff",
            opacity: 0.5,
            weight: 2
        };

           
            //let vecTileLayer = L.vectorGrid.protobuf("data/temporary_tiles/{z}/{x}/{y}.pbf", {
            let vecTileLayer = L.vectorGrid.protobuf("https://wam.rl-institut.de:84/data/zambia-vector/{z}/{x}/{y}.pbf", {
                    rendererFactory: L.canvas.tile,
                    vectorTileLayerStyles: {
                        borders: function(prop, zoom) {
                            return{
                            color: "white",
                            Opacity: 1,
                            weight: 1                
                            };    
                        },
                        clusters: function(prop, zoom) {
                            //if (prop.building < 250) {
                            //    amountcolor = "red";
                            //} else {
                            //    amountcolor = "green";
                            //}
                            //L.marker([prop.lon, prop.lat]).addTo(map);
                            return {
                                fill: true,
                                fillColor: "red",
                                fillOpacity: 0.5,
                                color: "#111111",
                                weight: 1
                            };
                        },
                    },
                    maxZoom: 15,
                    minZoom: 5,
                    interactive: true,
                getFeatureId: function(f) {
                    if (f.properties.ID !== undefined) {
                        return f.properties.ID;
                    }
                    if (f.properties.type !== undefined) {
                        return "g" + f.properties.ID;
                    }
                    return "r" + f.properties.OBJECTID;
                },
            })

            
            .on("click", function(e) {
                if (measuring == false){
                    this.clearHighlight();
                    let properties = e.layer.properties;
                    if (properties.ID !== undefined) {
                        var bbox = (properties.bb_south + ',' + properties.bb_west + ',' + properties.bb_north + ',' + properties.bb_east);
                        downloadstring =('http://overpass-api.de/api/interpreter?data=(node[building=yes](' + bbox + ');way[building=yes](' + bbox + '););(._;>;);out meta;');

                        // disableClickPropagation enables selecting and copying of text in control element
                        info.onAdd = function (map) {
                            this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
                            this.update();
                            L.DomEvent.disableClickPropagation(this._div);
                            return this._div;                        
                        };
                        // method that we will use to update the control based on feature properties passed  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a>

                        info.update = function (props) {
                            this._div.innerHTML = '<h4>Selection Detail</h4>' +
                                                  '<table>' + 
                                                  '<tr><td align="right"><b>ID</b>:</td><td>' + properties.ID + '</td></tr>' +  
                                                  '<tr><td align="right"><b>Province</b>:</td><td>'+properties.NAME_1+'</td></tr>' +
                                                  '<tr><td align="right"><b>Buildings</b>:</td><td>'+properties.building+'</td></tr>' +
                                                  '<tr><td align="right"><b>Area</b>:</td><td>'+properties.area_km2 + ' km²' + '</td></tr>' +
                                                  '<tr><td align="right"><b>Density</b>:</td><td>'+properties.buid_dens+'</td></tr>' +
                                                  '<tr><td align="right"><b>Distance to Grid</b>:</td><td>'+Math.round(properties.distance) + ' m' + '</td></tr>' +
                                                  '<tr><td align="right"><b>Priority Class</b>:</td><td>'+properties.prio_class+'</td></tr>' +
                                                  '<tr><td align="right"><b>Download Buildings</b>:</td><td>' + '<a href="' + downloadstring + '" > Link<a/>' +'</td></tr>' +
                                                  '</table>';
                            this._div.innerHTML
                        };
                        info.addTo(map);

                        var layers = [];
                        map.eachLayer(function(layer) {
                            if( layer instanceof L.TileLayer )
                                layers.push(layer);
                        });

                        currentSelection = properties.ID; 
                        var type = "c";
                        var ID = properties.ID;
                        let public=["School","Healthcare","Water Point","Public Building"].filter(function (v,i){i++;return i==properties.SC||i==properties.HC*2||i==properties.WC*3||i==properties.PC*4}).join(",<br/>");
                        public=public||"No Data";
                    } else {
                        var type = "r";
                        var ID = "r" + properties.ID;
                    }
                    if (type != "r") {
                        this.highlight = properties.ID;
                        this.setFeatureStyle(ID, highlightStyle);
                        L.DomEvent.stop(e);
                    }
                }
              }); 
        

        vecTileLayer.highlight = null;
        vecTileLayer.hidden = null;
        vecTileLayer.hiddenstyle = {
            color: "#668999",
            fillColor: "gray",
            fillOpacity: 0.1,
            opacity: 0.5,
            fill: true
        };
        vecTileLayer.clearHidden = function() {
            if (this.hiddenIDs) {
                for (let i = 0, len = this.hiddenIDs.length; i < len; i++) {
                    let id = this.hiddenIDs[i];
                    this.resetFeatureStyle(id);
                }
            }
        };

        vecTileLayer.clearHighlight = function() {
            // || this.highlight == 0 is necessary for the element with ID == 0
            if (this.highlight || this.highlight == 0) {
                if (this.hiddenIDs && this.hiddenIDs.indexOf(this.highlight) > -1){
                    this.setFeatureStyle(this.highlight, this.hiddenstyle); 
                } 
                else{
                    this.resetFeatureStyle(this.highlight);
                }
            }
            this.highlight = null;
            currentSelection = null;
            map.removeControl(info);
        };
                
        // the filter function selects objects by the limiting values set in the slider(s) 
        // and applies different styles to these selections. 
        vecTileLayer.filter = function(filter) {
            let newhiddenIDs = [];
            let vt = this._vectorTiles;
            for (let vtkey in vt) {
                let f = vt[vtkey]._features;
                for (let fkey in f) {
                    let prop = f[fkey].feature.properties;
                    if (
                            (prop.building >= currentfilter.minbuild && prop.building <= currentfilter.maxbuild) &&
                            (prop.buid_dens >= currentfilter.minbdens && prop.buid_dens <= currentfilter.maxbdens) &&
                            (prop.distance >= currentfilter.mindist && prop.distance <= currentfilter.maxdist) &&
                            (prop.area_km2 >= currentfilter.minarea && prop.area_km2 <= currentfilter.maxarea) 
                    )
                    {
                        this.setFeatureStyle(prop.ID, normalStyle);
                    }
                    else {
                        newhiddenIDs.push(prop.ID);
                        this.setFeatureStyle(prop.ID, this.hiddenstyle);
                    }
                    // when the map is panned or zoomed, the selected feature is newly styled 
                    // according to the filter parameters. In order to keen the object highlighted
                    // it is called and restyled again here.  
                    if (prop.ID == currentSelection) 
                    {
                        //alert(currentSelection);
                        this.setFeatureStyle(prop.ID, highlightStyle);
                    }
                }
            }
            this.hiddenIDs = newhiddenIDs;
        };

        var clusteracc = L.markerClusterGroup({chunkedLoading: true});
        clusteracc.addLayer(circles);
        //map.addLayer(clusteracc)    

        clusteracc.filter = function(filter, map) {
            this.clearLayers();
            let markerList = [];
            for (let i = 0; i < centroids.features.length; i++) {
                let point = centroids.features[i];
                //alert(point.properties.building)
                if (
                        point.properties.building >= currentfilter.minbuild && point.properties.building <= currentfilter.maxbuild &&
                        point.properties.buid_dens >= currentfilter.minbdens && point.properties.buid_dens <= currentfilter.maxbdens &&
                        point.properties.distance >= currentfilter.mindist && point.properties.distance <= currentfilter.maxdist &&
                        point.properties.area_km2 >= currentfilter.minarea && point.properties.area_km2 <= currentfilter.maxarea 
                )
                    {
                    let info = point.properties.building;
                    //alert(point.properties.lat + ' ' + point.properties.lon + ' ' + info);
                    //let marker = L.marker(L.latLng(point.properties.lon, point.properties.lat));
                    let orange =  L.circleMarker([point.properties.lon, point.properties.lat], {
                                   radius: 8,
                                   fillColor: "#ff7800",
                                   color: "#000",
                                   weight: 1,
                                   opacity: 1,
                                   fillOpacity: 0.8,
                        });
                    markerList.push(orange);
                }
            }
            this.addLayers(markerList);
            map.addLayer(this);
        };


  

        //L.marker([-14.456, 27.971]).addTo(map);

        map.addLayer(vecTileLayer);
        map.on("click", function() {
            vecTileLayer.clearHighlight();
        });

//        map.on("popupclose", function() {
//            vecTileLayer.clearHighlight();
//        });

 
        var sidebar = L.control.sidebar('sidebar', {
            position: 'left'
        });
        L.control.scale({
            position: "topright"
        }).addTo(map);
        L.control.zoom({
            position: "topright"
        }).addTo(map);

        var measurecontrol = L.control.measure(
            {
            //  control position
            position: 'topright',
            //  weather to use keyboard control for this plugin
            keyboard: true,
            //  shortcut to activate measure
            activeKeyCode: 'M'.charCodeAt(0),
            //  shortcut to cancel measure, defaults to 'Esc'
            cancelKeyCode: 27,
            //  line color
            lineColor: 'red',
            //  line weight
            lineWeight: 2,
            //  line dash
            lineDashArray: '6, 6',
            //  line opacity
            lineOpacity: 1
        });
        map.addControl(measurecontrol);

        var bob = L.control.measure(
            {
            //  control position
            position: 'topright',
            //  weather to use keyboard control for this plugin
            keyboard: true,
            //  shortcut to activate measure
            activeKeyCode: 'M'.charCodeAt(0),
            //  shortcut to cancel measure, defaults to 'Esc'
            cancelKeyCode: 27,
            //  line color
            lineColor: 'red',
            //  line weight
            lineWeight: 2,
            //  line dash
            lineDashArray: '6, 6',
            //  line opacity
            lineOpacity: 1
        });
        map.addControl(measurecontrol);

        map.addControl(sidebar);

            let baseMaps = {
                    "Esri Aerial": aerial,
                    "OpenStreetMap": osm,
                    "OpenTopoMap": topo,
            };



            // define and include overlaymaps
            let overlaymaps = {
                            "Clusters": vecTileLayer,
                            "Borders": borders,
                            "Centroids": circles,
                            "Cluster Accumulations": clusteracc,
                            "Solar Irradiation": ghi,
            };

            toggleVecTileLayer();
            toggleBorders();

            map.on('zoomend', function() {
                RefreshPreview();
            if (map.getZoom() >= 8) {
                //alert(map.getZoom());
                map.removeLayer(borders);
                document.getElementById('Borders').checked = false; 
            }
            if (map.getZoom() <= 8) {
                map.addLayer(borders);
                document.getElementById('Borders').checked = true; 
            }
            //map.fireEvent("filterchange", currentfilter);
            });
            map.on('moveend', function() {
                RefreshPreview();
                // when the map is panned, newly visible objects need to be filtered according 
                // to the selected parameters. the function to do so is called here.
                map.fireEvent("mapmove", currentfilter);
            });

            map.on("layeradd",function (){vecTileLayer.bringToFront();});

            map.addEventListener("filterchange", function(filter) {
                vecTileLayer.filter(currentfilter);
                clusteracc.filter(currentfilter, map);
            });

            map.addEventListener("mapmove", function(filter) {
                vecTileLayer.filter(currentfilter);
            });


        </script>
    
        
    </body>

</html>



